// RobotBuilder Version: 2.0
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.


package org.usfirst.frc4089.Stealth2018.subsystems;

import org.usfirst.frc4089.Stealth2018.Constants;
import org.usfirst.frc4089.Stealth2018.RobotMap;
import org.usfirst.frc4089.Stealth2018.commands.*;

import com.ctre.CANTalon;

import edu.wpi.first.wpilibj.Encoder;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj.RobotDrive;
import edu.wpi.first.wpilibj.SpeedController;
import edu.wpi.first.wpilibj.Talon;
import edu.wpi.first.wpilibj.TalonSRX;
import edu.wpi.first.wpilibj.XboxController;
import edu.wpi.first.wpilibj.command.Subsystem;


/**
 *
 */
public class Drive extends Subsystem {

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=CONSTANTS

    // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public final CANTalon rightMotor1 = RobotMap.driveRightMotor1;
    public final SpeedController rightMotor2 = RobotMap.driveRightMotor2;
    public final CANTalon leftMotor1 = RobotMap.driveLeftMotor1;
    public final SpeedController leftMotor2 = RobotMap.driveLeftMotor2;
    public final RobotDrive robotDrive41 = RobotMap.driveRobotDrive41;
    public final Encoder rightEncoder = RobotMap.rightEncoder;
    public final Encoder leftEncoder = RobotMap.leftEncoder;

    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DECLARATIONS
    public double rightSpeed = 0;
    public double leftSpeed = 0;
    
    
    
    // Put methods for controlling this subsystem
    // here. Call these from Commands.

    public void initDefaultCommand() {
        // BEGIN AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND


    // END AUTOGENERATED CODE, SOURCE=ROBOTBUILDER ID=DEFAULT_COMMAND

        // Set the default command for a subsystem here.
        // setDefaultCommand(new MySpecialCommand());
    	setDefaultCommand(new UserDrive());
    	//leftMotor1.reverseSensor(true);
    }
    public void operatorDrive(Joystick DriveStick){
    	arcDrive(-DriveStick.getRawAxis(2), DriveStick.getRawAxis(1));
    	
    }
    
	private void arcDrive(double turn, double pow) {
		robotDrive41.arcadeDrive(turn, pow + Constants.curve);
		
	}
    /**
    *
    * @param drivestick
    * @param utilitystick
    */	
	public void operatorTankDrive(Joystick joystick1, Joystick joystick2){
        //inverts the motor drive for the connections to drive forward (when pickup is down)
        //System.out.println("control FW");        
        //robotDrive.setInvertedMotor(RobotDrive.MotorType.kFrontLeft, true);
        //robotDrive.setInvertedMotor(RobotDrive.MotorType.kRearLeft, true);
        //robotDrive.setInvertedMotor(RobotDrive.MotorType.kFrontRight, true);
        //robotDrive.setInvertedMotor(RobotDrive.MotorType.kRearRight, true);
            
        robotDrive41.tankDrive(joystick1, joystick2);
	}
    /**
    *
    * @param XboxAxisL
    * @param XboxAxisR
    */
	public void operatorXBOXTankDrive(double XboxAxisL, double XboxAxisR){
        //inverts the motor drive for the connections to drive forward (when pickup is down)
        //System.out.println("control FW");        
        //robotDrive.setInvertedMotor(RobotDrive.MotorType.kFrontLeft, true);
        //robotDrive.setInvertedMotor(RobotDrive.MotorType.kRearLeft, true);
        //robotDrive.setInvertedMotor(RobotDrive.MotorType.kFrontRight, true);
        //robotDrive.setInvertedMotor(RobotDrive.MotorType.kRearRight, true);
            
        robotDrive41.tankDrive(-XboxAxisR,XboxAxisL);
	}    
	public void driveF(){
		System.out.println("driveF");
		rightMotor1.set(.5);
		rightMotor2.set(.5);
		leftMotor1.set(.671);
		leftMotor2.set(.671);
	}
	public void driveB(){
		rightMotor1.set(-1);
		rightMotor2.set(-1);
		leftMotor1.set(-1);
		leftMotor2.set(-1);
	}
	public void driveR(){
		rightMotor1.set(-1);
		rightMotor2.set(-1);
		leftMotor1.set(.8);
		leftMotor2.set(8);
	}
	public void driveL(){
		rightMotor1.set(1);
		rightMotor2.set(1);
		leftMotor1.set(-1);
		leftMotor2.set(-1);
	}
	public void stop(){
		rightMotor1.set(0);
		rightMotor2.stopMotor();
		leftMotor1.set(0);
		leftMotor2.stopMotor();
	}
	
	/**
	 * Tank drive is (left, right)
	 */
	public void tankDrive(double leftValue, double rightValue){
		robotDrive41.tankDrive(leftValue, -rightValue);
	}
	/*public void debugR1(){
		leftMotor1.set(.2);
	}
	public void debugR2(){
		leftMotor2.set(.2);
	}*/
	
	public void resetEncoders(){
		rightEncoder.reset();
		//leftMotor1.setEncPosition(0);
		leftEncoder.reset();
	}
	public double getLeftEncoderDist(){
		//return leftEncoder.getDistance();
		return RobotMap.driveLeftMotor1.getEncPosition();
	}
	public double getRightEncoderDist(){
		//return rightEncoder.getDistance();
		return RobotMap.driveRightMotor1.getEncPosition();
	}
	public double getLeftEncoderRate(){
		//return leftEncoder.getRate(); //dist per sec
		return RobotMap.driveLeftMotor1.getEncVelocity();
	}
	public double getRightEncoderRate(){
		//return rightEncoder.getRate(); //dist per sec
		return RobotMap.driveRightMotor1.getEncVelocity();
	}
	
}

